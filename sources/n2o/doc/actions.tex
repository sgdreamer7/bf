\section{Actions}

\paragraph{}
{\bf \#action} record is basic for all actions. It means that each action
has {\bf \#action} as its ancestor.

\vspace{1\baselineskip}
\begin{lstlisting}
    #action { ancestor,
              target,
              module,
              actions,
              source=[] }.
\end{lstlisting}
\vspace{1\baselineskip}

{\bf target} specifies an element where this action will arise.

\subsection{JavaScript DSL {\bf \#jq}}
JavaScript query selector action mimics JavaScript calls and assignments.
Depending on filling property or method field specific action performs.

\vspace{1\baselineskip}
\begin{lstlisting}
    -record(jq, {?ACTION_BASE(action_jq),
            property,
            method,
            args=[],
            right }).
\end{lstlisting}
\vspace{1\baselineskip}

Here is an example of method calls:
\begin{lstlisting}
    wf:wire(#jq{target=n2ostatus,method=[show,select]}).
\end{lstlisting}
unfolded to calls:
\begin{lstlisting}
    document.querySelector('#n2ostatus').show();
    document.querySelector('#n2ostatus').select();
\end{lstlisting}
\vspace{1\baselineskip}

And here is example of property chained assignments:
\begin{lstlisting}
    wf:wire(#jq{target=history,property=scrollTop,
        right=#jq{target=history,property=scrollHeight}}).
\end{lstlisting}
which transforms to:
\begin{lstlisting}
    document.querySelector('#history').scrollTop =
        document.querySelector('#history').scrollHeight;
\end{lstlisting}
\vspace{1\baselineskip}
Part of N2O API is implemented using \#jq actions (updates and redirect).
This action is introduced as transitional in order to move
from Nitrogen DSL to using pure JavaScript transformations.

\subsection*{Event Actions}
Objects passed over WebSockets channel from server to client are called actions.
Objects passed over the same channel from client to server are called events. However
events themselves are bound to HTML elements with {\bf addEventListener} and in order to perform these bindings
actions should be sent first. Such actions are called event actions. Three type
of event actions exist.

\subsection{Page Events \#event}
Page events are regular events that are routed to calling module. Postback field is used as main
routing parameter to {\bf event} module function. By providing {\bf source} elements list
values from HTML controls gathered and packet for use with {\bf wf:q} accessor from page context.
Page events are normally generated by active elements like {\bf \#button}, {\bf \#link},
{\bf \#textbox}, {\bf \#dropdown}, {\bf \#select}, {\bf \#radio} and others elements
containing postback field.

\paragraph{}
Control events are dedicated to solve the need of elements writers. When you develop your
own control elements you usually want events to be routed not to page but to element module.
For this purpose control events were introduced.

\subsection{API Events \#api}
When you need to call Erlang function from JavaScript directly you use API events.
API events are routed to page module with {\bf api\_event/3} function. API events were
used in {\bf AVZ} authorization library. Here is an example of how JSON login could be
implemented using api\_event:

\vspace{1\baselineskip}
\begin{lstlisting}
    api_event(appLogin, Args, Term) ->
        Struct = n2o_json:decode(Args),
        wf:info("Granted Access"),
        wf:redirect("/account").
\end{lstlisting}
\vspace{1\baselineskip}
And from JavaScript you call it like that:
\vspace{1\baselineskip}
\begin{lstlisting}
    document.appLogin(JSON.stringify(response));
\end{lstlisting}
\vspace{1\baselineskip}
All API events are bound to root of the HTML document.


\subsection{Message Box \#alert}
Message box {\bf alert} is a very simple dialog useful for client debugging.
You can use {\bf console.log} along with alerts.

\vspace{1\baselineskip}
\begin{lstlisting}
    event({debug,Var}) ->
        wf:wire(#alert{text="Debug: " ++ wf:to_list(Var)}),
\end{lstlisting}

\subsection{Confirmation Box \#confirm}
You can use confirmation boxes for simple approval with JavaScript {\bf confirm} dialogs.
You should extend this action in order to build custom dialogs. Confirmation box is just an example of how to
organize this type of logic.

\vspace{1\baselineskip}
\begin{lstlisting}
    event(confirm) ->
        wf:wire(#confirm{text="Are you happy?",postback=continue}),

    event(continue) -> wf:info("Yes, you're right!");
\end{lstlisting}
\vspace{1\baselineskip}
